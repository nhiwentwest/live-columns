/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => LiveColumnsPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// liveColumnsExtension.ts
var import_view = require("@codemirror/view");
var import_state = require("@codemirror/state");
var import_obsidian = require("obsidian");
function buildColumnsMarkdown(numColumns, columns, colors, borders) {
  const lines = [];
  const normalized = [...columns];
  while (normalized.length < numColumns)
    normalized.push("");
  lines.push(`%% columns:start ${numColumns} %%`);
  if (colors && colors.length) {
    const colorLine = colors.slice(0, numColumns).join("|");
    lines.push(`%% columns:colors ${colorLine} %%`);
  }
  if (borders && borders.length) {
    const borderLine = borders.slice(0, numColumns).join("|");
    lines.push(`%% columns:borders ${borderLine} %%`);
  }
  normalized.slice(0, numColumns).forEach((col, idx) => {
    if (idx > 0)
      lines.push("--- col ---");
    lines.push(col);
  });
  lines.push("%% columns:end %%");
  return lines.join("\n");
}
var ColumnsWidget = class extends import_view.WidgetType {
  constructor(block, view) {
    super();
    this.block = block;
    this.view = view;
    this.container = null;
    this.isUpdating = false;
    this.columnContents = [...this.block.columns];
    while (this.columnContents.length < this.block.numColumns) {
      this.columnContents.push("");
    }
  }
  toDOM() {
    this.container = document.createElement("div");
    this.container.className = `live-columns-container live-columns-${this.block.numColumns}`;
    this.container.setAttribute("data-live-columns", "true");
    this.container.setAttribute("tabindex", "0");
    for (let i = 0; i < this.block.numColumns; i++) {
      const colDiv = this.createColumn(i);
      this.container.appendChild(colDiv);
    }
    this.container.addEventListener("keydown", (e) => {
      const target = e.target;
      if (target.hasAttribute("contenteditable"))
        return;
      if (e.key === "Delete" || e.key === "Backspace") {
        e.preventDefault();
        e.stopPropagation();
        this.deleteEntireBlock();
      }
    });
    this.container.addEventListener("click", (e) => {
      const target = e.target;
      if (target === this.container) {
        this.container.focus();
      }
    });
    const deleteBtn = document.createElement("button");
    deleteBtn.className = "live-columns-delete-btn";
    deleteBtn.innerHTML = "\u{1F5D1}\uFE0F Delete";
    deleteBtn.title = "Delete this column block";
    deleteBtn.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      this.deleteEntireBlock();
    });
    this.container.appendChild(deleteBtn);
    return this.container;
  }
  /**
   * Delete the entire column block from the document
   */
  deleteEntireBlock() {
    const doc = this.view.state.doc;
    const text = doc.toString();
    const startRe = /%%\s*columns:start\s+(\d+)\s*%{1,2}/gi;
    let match;
    let from = -1;
    let to = -1;
    while ((match = startRe.exec(text)) !== null) {
      const num = parseInt(match[1], 10);
      if (num === this.block.numColumns) {
        from = match.index;
        const endRe = /%%\s*columns:end\s*%{1,2}/gi;
        endRe.lastIndex = startRe.lastIndex;
        const endMatch = endRe.exec(text);
        if (endMatch) {
          to = endMatch.index + endMatch[0].length;
        }
        break;
      }
    }
    if (from === -1 || to === -1) {
      console.error("Live Columns: Could not find block to delete");
      return;
    }
    let deleteTo = to;
    if (deleteTo < doc.length && doc.sliceString(deleteTo, deleteTo + 1) === "\n") {
      deleteTo++;
    }
    this.view.dispatch({
      changes: { from, to: deleteTo }
    });
  }
  createColumn(index) {
    var _a, _b;
    const colDiv = document.createElement("div");
    colDiv.className = "live-column";
    colDiv.setAttribute("data-column-index", index.toString());
    colDiv.setAttribute("contenteditable", "true");
    colDiv.setAttribute("spellcheck", "true");
    colDiv.setAttribute("data-placeholder", `Column ${index + 1}`);
    const colorClass = (_a = this.block.colors[index]) == null ? void 0 : _a.trim();
    if (colorClass) {
      colDiv.classList.add(`live-col-${colorClass}`);
    }
    const borderClass = (_b = this.block.borders[index]) == null ? void 0 : _b.trim();
    if (borderClass) {
      colDiv.classList.add(`live-border-${borderClass}`);
    }
    const content = this.columnContents[index] || "";
    this.setColumnContent(colDiv, content, false);
    colDiv.addEventListener("keydown", (e) => {
      this.handleKeydown(e, index);
    });
    colDiv.addEventListener("focus", () => {
      const currentContent = this.columnContents[index] || "";
      this.setColumnContent(colDiv, currentContent, true);
      colDiv.classList.add("live-column-editing");
    });
    colDiv.addEventListener("blur", () => {
      const rawText = colDiv.innerText || "";
      this.columnContents[index] = rawText.trim();
      this.setColumnContent(colDiv, this.columnContents[index], false);
      colDiv.classList.remove("live-column-editing");
      this.syncToSource();
    });
    let inputTimeout = null;
    colDiv.addEventListener("input", () => {
      const rawText = colDiv.innerText || "";
      this.columnContents[index] = rawText.trim();
      if (inputTimeout)
        clearTimeout(inputTimeout);
      inputTimeout = setTimeout(() => {
        this.syncToSource();
      }, 300);
    });
    colDiv.addEventListener("paste", (e) => {
      var _a2;
      e.preventDefault();
      const text = ((_a2 = e.clipboardData) == null ? void 0 : _a2.getData("text/plain")) || "";
      const selection = window.getSelection();
      if (selection && selection.rangeCount > 0) {
        const range = selection.getRangeAt(0);
        range.deleteContents();
        const textNode = document.createTextNode(text);
        range.insertNode(textNode);
        range.setStartAfter(textNode);
        range.setEndAfter(textNode);
        selection.removeAllRanges();
        selection.addRange(range);
      }
    });
    return colDiv;
  }
  /**
   * Set column content in either rendered or raw mode
   * @param colDiv - The column element
   * @param content - The markdown content
   * @param rawMode - If true, show raw markdown text. If false, show rendered HTML.
   */
  setColumnContent(colDiv, content, rawMode) {
    while (colDiv.firstChild) {
      colDiv.removeChild(colDiv.firstChild);
    }
    if (rawMode) {
      colDiv.innerText = content || "";
    } else {
      const htmlContent = this.renderContent(content);
      const parser = new DOMParser();
      const doc = parser.parseFromString(htmlContent, "text/html");
      Array.from(doc.body.childNodes).forEach((node) => colDiv.appendChild(node));
    }
  }
  /**
   * Render markdown content as HTML
   */
  renderContent(text) {
    if (!text.trim()) {
      return "<br>";
    }
    let html = text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/^(#{1,6})\s+(.+)$/gm, (_, hashes, content) => {
      const level = hashes.length;
      return `<h${level}>${content}</h${level}>`;
    }).replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>").replace(/\*(.+?)\*/g, "<em>$1</em>").replace(/`(.+?)`/g, "<code>$1</code>").replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2">$1</a>').replace(/^[-*]\s+(.+)$/gm, "<li>$1</li>").replace(/^\d+\.\s+(.+)$/gm, "<li>$1</li>").replace(/((?:<li>.+?<\/li>\n?)+)/g, "<ul>$1</ul>").replace(/^(?!<[hulo])(.+)$/gm, "<div>$1</div>");
    html = html.replace(/\n/g, "<br>");
    return html;
  }
  /**
   * Extract plain text/markdown from HTML
   * FIXED: Improved logic to handle div/br combinations without adding extra lines
   */
  extractContent(el) {
    const clone = el.cloneNode(true);
    let text = clone.innerHTML.replace(/<h(\d)>(.+?)<\/h\1>/gi, (_, level, content) => {
      return "#".repeat(parseInt(level)) + " " + content + "\n";
    }).replace(/<strong>(.+?)<\/strong>/gi, "**$1**").replace(/<b>(.+?)<\/b>/gi, "**$1**").replace(/<em>(.+?)<\/em>/gi, "*$1*").replace(/<i>(.+?)<\/i>/gi, "*$1*").replace(/<code>(.+?)<\/code>/gi, "`$1`").replace(/<a href="([^"]+)">(.+?)<\/a>/gi, "[$2]($1)").replace(/<li>(.+?)<\/li>/gi, "- $1\n").replace(/<\/?[uo]l>/gi, "").replace(/<div[^>]*><br><\/div>/gi, "\n").replace(/<div[^>]*>/gi, "\n").replace(/<\/div>/gi, "").replace(/<p[^>]*>/gi, "\n").replace(/<\/p>/gi, "").replace(/<br\s*\/?>/gi, "\n").replace(/<[^>]+>/g, "").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&").replace(/&nbsp;/g, " ").replace(/^\n+/, "").replace(/\n+$/, "").replace(/\n{3,}/g, "\n\n").trim();
    return text;
  }
  syncToSource() {
    if (this.isUpdating || !this.container)
      return;
    this.isUpdating = true;
    try {
      const newContents = [];
      const columns = this.container.querySelectorAll(".live-column");
      columns.forEach((col) => {
        const content = this.extractContent(col);
        newContents.push(content);
      });
      const hasChanges = newContents.some(
        (content, i) => content !== (this.columnContents[i] || "")
      );
      if (!hasChanges) {
        this.isUpdating = false;
        return;
      }
      this.columnContents = newContents;
      const doc = this.view.state.doc;
      const text = doc.toString();
      const startRe = /%%\s*columns:start\s+(\d+)\s*%{1,2}/gi;
      let currentBlock = null;
      let match;
      while ((match = startRe.exec(text)) !== null) {
        const startPos = match.index;
        const endRe = /%%\s*columns:end\s*%{1,2}/gi;
        endRe.lastIndex = startRe.lastIndex;
        const endMatch = endRe.exec(text);
        if (endMatch) {
          const endPos = endMatch.index + endMatch[0].length;
          const num = parseInt(match[1], 10);
          if (num === this.block.numColumns) {
            const blockContent = text.slice(startRe.lastIndex, endMatch.index);
            const colorLineRe = /%%\s*columns:colors\s+([^\n%]+)\s*%{1,2}/i;
            const borderLineRe = /%%\s*columns:borders\s+([^\n%]+)\s*%{1,2}/i;
            const colorMatch = blockContent.match(colorLineRe);
            const borderMatch = blockContent.match(borderLineRe);
            currentBlock = {
              startPos,
              endPos,
              colors: colorMatch ? colorMatch[1].split("|").map((c) => c.trim()) : [],
              borders: borderMatch ? borderMatch[1].split("|").map((b) => b.trim()) : []
            };
            break;
          }
        }
      }
      if (!currentBlock) {
        currentBlock = {
          startPos: this.block.startPos,
          endPos: this.block.endPos,
          colors: this.block.colors,
          borders: this.block.borders
        };
      }
      const from = Math.max(0, Math.min(currentBlock.startPos, doc.length));
      const to = Math.max(from, Math.min(currentBlock.endPos, doc.length));
      const newMarkdown = buildColumnsMarkdown(
        this.block.numColumns,
        newContents,
        currentBlock.colors,
        // Use current colors from document
        currentBlock.borders
        // Use current borders from document
      );
      const transaction = this.view.state.update({
        changes: {
          from,
          to,
          insert: newMarkdown
        },
        annotations: import_state.Transaction.userEvent.of("input.columns")
      });
      this.view.dispatch(transaction);
    } catch (e) {
      console.error("Live Columns: sync error", e);
    } finally {
      this.isUpdating = false;
    }
  }
  // ... (Giữ nguyên handleKeydown, eq, ignoreEvent, destroy) ...
  handleKeydown(e, columnIndex) {
    var _a;
    if (e.key === "a" && (e.metaKey || e.ctrlKey)) {
      e.preventDefault();
      e.stopPropagation();
      const columns = (_a = this.container) == null ? void 0 : _a.querySelectorAll(".live-column");
      const currentCol = columns == null ? void 0 : columns[columnIndex];
      if (currentCol) {
        const range = document.createRange();
        range.selectNodeContents(currentCol);
        const sel = window.getSelection();
        sel == null ? void 0 : sel.removeAllRanges();
        sel == null ? void 0 : sel.addRange(range);
      }
      return;
    }
    if (e.key === "Tab" && this.container) {
      e.preventDefault();
      const columns = this.container.querySelectorAll(".live-column");
      const nextIndex = e.shiftKey ? (columnIndex - 1 + columns.length) % columns.length : (columnIndex + 1) % columns.length;
      const nextCol = columns[nextIndex];
      if (nextCol) {
        nextCol.focus();
        const range = document.createRange();
        range.selectNodeContents(nextCol);
        range.collapse(false);
        const sel = window.getSelection();
        sel == null ? void 0 : sel.removeAllRanges();
        sel == null ? void 0 : sel.addRange(range);
      }
    }
  }
  eq(other) {
    if (this.block.numColumns !== other.block.numColumns)
      return false;
    if (this.block.columns.length !== other.block.columns.length)
      return false;
    for (let i = 0; i < this.block.columns.length; i++) {
      if (this.block.columns[i] !== other.block.columns[i])
        return false;
    }
    return true;
  }
  /**
   * Update the existing DOM instead of recreating it
   * This preserves user edits in contenteditable when document changes elsewhere
   */
  updateDOM(dom, view) {
    this.view = view;
    this.container = dom;
    return true;
  }
  ignoreEvent() {
    return true;
  }
  destroy() {
    this.container = null;
  }
};
function findColumnsBlocks(view) {
  const text = view.state.doc.toString();
  const blocks = [];
  const startRe = /%%\s*columns:start\s+(\d+)\s*%{1,2}/gi;
  let match;
  while ((match = startRe.exec(text)) !== null) {
    const num = parseInt(match[1], 10);
    if (isNaN(num) || num < 1 || num > 6)
      continue;
    const startPos = match.index;
    const startMarkerLen = match[0].length;
    const endRe = /%%\s*columns:end\s*%{1,2}/gi;
    endRe.lastIndex = startRe.lastIndex;
    const endMatch = endRe.exec(text);
    if (!endMatch)
      continue;
    const endPos = endMatch.index + endMatch[0].length;
    const endMarkerLen = endMatch[0].length;
    const blockContent = text.slice(startRe.lastIndex, endMatch.index);
    const blockLines = blockContent.split(/\r?\n/);
    const colorLineRe = /^%%\s*columns:colors\s+([^\n%]+)\s*%{1,2}\s*$/i;
    const borderLineRe = /^%%\s*columns:borders\s+([^\n%]+)\s*%{1,2}\s*$/i;
    let colors = [];
    let borders = [];
    let metadataLen = 0;
    let idx = 0;
    while (idx < blockLines.length) {
      const line = blockLines[idx];
      const trimmedLine = line.trim();
      if (!trimmedLine) {
        metadataLen += line.length + 1;
        blockLines.splice(idx, 1);
        continue;
      }
      const colorMatch = trimmedLine.match(colorLineRe);
      if (colorMatch) {
        colors = colorMatch[1].split("|").map((c) => c.trim());
        metadataLen += line.length + 1;
        blockLines.splice(idx, 1);
        continue;
      }
      const borderMatch = trimmedLine.match(borderLineRe);
      if (borderMatch) {
        borders = borderMatch[1].split("|").map((b) => b.trim());
        metadataLen += line.length + 1;
        blockLines.splice(idx, 1);
        continue;
      }
      break;
    }
    const totalStartMarkerLen = startMarkerLen + metadataLen;
    const bodyText = blockLines.join("\n");
    const cols = parseColumnsFromBody(bodyText, num);
    blocks.push({
      numColumns: num,
      columns: cols,
      startPos,
      endPos,
      startMarkerLen: totalStartMarkerLen,
      endMarkerLen,
      colors,
      borders
    });
    startRe.lastIndex = endMatch.index + endMatch[0].length;
  }
  return blocks;
}
function parseColumnsFromBody(body, numColumns) {
  const parts = body.split(/^\s*---\s*col\s*---\s*$/im);
  const result = [];
  for (let i = 0; i < numColumns; i++) {
    result.push((parts[i] || "").trim());
  }
  return result;
}
var columnsViewPlugin = import_view.ViewPlugin.fromClass(
  class {
    constructor(view) {
      this.decorations = this.buildDecorations(view);
      this.lastIsLivePreview = view.state.field(import_obsidian.editorLivePreviewField, false) || false;
    }
    update(update) {
      const isLivePreviewNow = update.view.state.field(import_obsidian.editorLivePreviewField, false) || false;
      const modeChanged = isLivePreviewNow !== this.lastIsLivePreview;
      this.lastIsLivePreview = isLivePreviewNow;
      if (update.docChanged || update.viewportChanged || modeChanged) {
        this.decorations = this.buildDecorations(update.view);
      }
    }
    buildDecorations(view) {
      try {
        const isLivePreview = view.state.field(import_obsidian.editorLivePreviewField, false);
        if (!isLivePreview) {
          return import_view.Decoration.none;
        }
        const builder = new import_state.RangeSetBuilder();
        const blocks = findColumnsBlocks(view);
        for (const block of blocks) {
          const docLength = view.state.doc.length;
          const from = Math.max(0, Math.min(block.startPos, docLength));
          const to = Math.max(from, Math.min(block.endPos, docLength));
          if (from === to)
            continue;
          const widget = import_view.Decoration.widget({
            widget: new ColumnsWidget(block, view),
            // keep inline to satisfy Obsidian CM6 restriction
            block: false
          });
          builder.add(from, from, widget);
          const startHideTo = Math.min(docLength, from + block.startMarkerLen);
          if (startHideTo > from) {
            builder.add(
              from,
              startHideTo,
              import_view.Decoration.mark({ class: "live-columns-marker-hidden", inclusive: false })
            );
          }
          const endFrom = Math.max(from, to - block.endMarkerLen);
          if (endFrom > startHideTo) {
            builder.add(
              startHideTo,
              endFrom,
              import_view.Decoration.mark({ class: "live-columns-body-hidden", inclusive: false })
            );
          }
          if (to > endFrom) {
            builder.add(
              endFrom,
              to,
              import_view.Decoration.mark({ class: "live-columns-marker-hidden", inclusive: false })
            );
          }
        }
        return builder.finish();
      } catch (e) {
        console.error("Live Columns: decoration build error", e);
        return import_view.Decoration.none;
      }
    }
  },
  {
    decorations: (v) => v.decorations
  }
);
var blockCollapsedInput = import_state.EditorState.transactionFilter.of((tr) => {
  const isLivePreview = tr.startState.field(import_obsidian.editorLivePreviewField, false);
  if (!isLivePreview)
    return tr;
  if (!tr.docChanged)
    return tr;
  const changes = tr.changes;
  let blocked = false;
  changes.iterChanges((fromA, toA) => {
    const doc = tr.startState.doc;
    const text = doc.toString();
    const startPattern = /%%\s*columns:start\s+(\d+)\s*%{1,2}/gi;
    const endPattern = /%%\s*columns:end\s*%{1,2}/gi;
    let match;
    while ((match = startPattern.exec(text)) !== null) {
      const blockStart = match.index;
      endPattern.lastIndex = startPattern.lastIndex;
      const endMatch = endPattern.exec(text);
      if (endMatch) {
        const blockEnd = endMatch.index + endMatch[0].length;
        const firstLineEnd = blockStart + match[0].length;
        if (fromA > firstLineEnd && fromA <= blockEnd) {
          blocked = true;
        }
      }
    }
  });
  if (blocked) {
    return [];
  }
  return tr;
});
var cursorAutoJump = import_view.EditorView.updateListener.of((update) => {
  if (!update.selectionSet)
    return;
  const isLivePreview = update.state.field(import_obsidian.editorLivePreviewField, false);
  if (!isLivePreview)
    return;
  const cursor = update.state.selection.main.head;
  const doc = update.state.doc;
  const text = doc.toString();
  const startPattern = /%%\s*columns:start\s+(\d+)\s*%{1,2}/gi;
  const endPattern = /%%\s*columns:end\s*%{1,2}/gi;
  let match;
  while ((match = startPattern.exec(text)) !== null) {
    const blockStart = match.index;
    const firstLineEnd = blockStart + match[0].length;
    endPattern.lastIndex = startPattern.lastIndex;
    const endMatch = endPattern.exec(text);
    if (endMatch) {
      const blockEnd = endMatch.index + endMatch[0].length;
      if (cursor > firstLineEnd && cursor <= blockEnd) {
        const targetPos = Math.min(blockEnd + 1, doc.length);
        requestAnimationFrame(() => {
          update.view.dispatch({
            selection: { anchor: targetPos }
          });
        });
        return;
      }
    }
  }
});
function liveColumnsExtension() {
  return [columnsViewPlugin, blockCollapsedInput, cursorAutoJump];
}

// main.ts
var LIVE_COLUMNS_ICON = `
<svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" fill="none">
  <rect x="10" y="18" width="35" height="64" rx="6" fill="currentColor" fill-opacity="0.12" stroke="currentColor" stroke-width="4"/>
  <rect x="55" y="18" width="35" height="64" rx="6" fill="currentColor" fill-opacity="0.12" stroke="currentColor" stroke-width="4"/>
</svg>
`;
var LiveColumnsPlugin = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    // Flag for column selection mode
    this.isSelectingColumn = false;
    this.columnClickHandler = null;
  }
  onload() {
    (0, import_obsidian2.addIcon)("live-columns", LIVE_COLUMNS_ICON);
    const ribbon = this.addRibbonIcon("live-columns", "Insert columns / colors", (evt) => {
      const menu = new import_obsidian2.Menu();
      menu.addItem(
        (item) => item.setTitle("Insert 2 columns").setIcon("columns").onClick(() => this.insertColumnsAtActive(2))
      );
      menu.addItem(
        (item) => item.setTitle("Insert 3 columns").setIcon("columns").onClick(() => this.insertColumnsAtActive(3))
      );
      menu.addItem(
        (item) => item.setTitle("Insert 1 column (full width)").setIcon("columns").onClick(() => this.insertColumnsAtActive(1))
      );
      menu.addSeparator();
      menu.addItem(
        (item) => item.setTitle("Change background color...").setIcon("palette").onClick(() => this.enterColumnSelectionMode("color"))
      );
      menu.addItem(
        (item) => item.setTitle("Change border color...").setIcon("square").onClick(() => this.enterColumnSelectionMode("border"))
      );
      menu.showAtMouseEvent(evt);
    });
    ribbon.addClass("live-columns-ribbon");
    this.registerMarkdownPostProcessor(this.columnsPostProcessor.bind(this));
    this.registerEditorExtension(liveColumnsExtension());
    this.registerCommands();
  }
  onunload() {
    this.exitColumnSelectionMode();
  }
  /**
   * Enter column selection mode - wait for user to click on a column
   */
  enterColumnSelectionMode(type = "color") {
    if (this.isSelectingColumn) {
      this.exitColumnSelectionMode();
      return;
    }
    this.isSelectingColumn = true;
    const msg = type === "color" ? "background" : "border";
    if (document.activeElement instanceof HTMLElement) {
      document.activeElement.blur();
    }
    new import_obsidian2.Notice(`\u{1F446} Click on a column to change its ${msg} color...`, 5e3);
    document.body.classList.add("live-columns-selecting");
    this.columnClickHandler = (e) => {
      const target = e.target;
      const column = target.closest(".live-column");
      const container = target.closest(".live-columns-container");
      if (column && container) {
        e.preventDefault();
        e.stopPropagation();
        const columnIndex = parseInt(column.getAttribute("data-column-index") || "0", 10);
        const allContainers = document.querySelectorAll(".live-columns-container");
        let blockIndex = 0;
        for (let i = 0; i < allContainers.length; i++) {
          if (allContainers[i] === container) {
            blockIndex = i;
            break;
          }
        }
        this.exitColumnSelectionMode();
        this.showColorPaletteForColumn(columnIndex, type, blockIndex, container);
      }
    };
    document.addEventListener("click", this.columnClickHandler, true);
    setTimeout(() => {
      if (this.isSelectingColumn) {
        this.exitColumnSelectionMode();
        new import_obsidian2.Notice("Column selection cancelled.");
      }
    }, 1e4);
  }
  /**
   * Exit column selection mode
   */
  exitColumnSelectionMode() {
    this.isSelectingColumn = false;
    document.body.classList.remove("live-columns-selecting");
    if (this.columnClickHandler) {
      document.removeEventListener("click", this.columnClickHandler, true);
      this.columnClickHandler = null;
    }
  }
  /**
   * Show color palette after user selected a column
   */
  showColorPaletteForColumn(columnIndex, type, blockIndex = 0, widgetContainer) {
    const view = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
    const editor = view == null ? void 0 : view.editor;
    if (!editor) {
      new import_obsidian2.Notice("Editor not found.");
      return;
    }
    const doc = editor.getValue();
    const startRe = /%%\s*columns:start\s+(\d+)\s*%%/g;
    let startMatch = null;
    let matchCount = 0;
    while ((startMatch = startRe.exec(doc)) !== null) {
      if (matchCount === blockIndex) {
        break;
      }
      matchCount++;
    }
    if (!startMatch) {
      new import_obsidian2.Notice("Kh\xF4ng t\xECm th\u1EA5y block columns.");
      return;
    }
    const num = parseInt(startMatch[1], 10);
    if (isNaN(num) || num < 1) {
      new import_obsidian2.Notice("Invalid columns block.");
      return;
    }
    if (columnIndex >= num) {
      new import_obsidian2.Notice(`Block only has ${num} columns, you selected column ${columnIndex + 1}.`);
      return;
    }
    const startPos = startMatch.index;
    const endRe = /%%\s*columns:end\s*%%/g;
    endRe.lastIndex = startRe.lastIndex;
    const endMatch = endRe.exec(doc);
    if (!endMatch) {
      new import_obsidian2.Notice("Columns block missing end marker.");
      return;
    }
    const endPos = endMatch.index + endMatch[0].length;
    const blockText = doc.slice(startPos, endPos);
    const blockLines = blockText.split(/\r?\n/);
    const colorLineRe = /^%%\s*columns:colors\s+([^\n%]+)\s*%{1,2}\s*$/i;
    const borderLineRe = /^%%\s*columns:borders\s+([^\n%]+)\s*%{1,2}\s*$/i;
    let colors = [];
    let borders = [];
    for (let i = 1; i < blockLines.length - 1; i++) {
      const line = blockLines[i].trim();
      if (!line) {
        continue;
      }
      const colorMatch = line.match(colorLineRe);
      if (colorMatch) {
        colors = colorMatch[1].split("|").map((c) => c.trim());
        continue;
      }
      const borderMatch = line.match(borderLineRe);
      if (borderMatch) {
        borders = borderMatch[1].split("|").map((c) => c.trim());
        continue;
      }
      break;
    }
    while (colors.length < num)
      colors.push("");
    while (borders.length < num)
      borders.push("");
    const typeName = type === "color" ? "background" : "border";
    const palette = [
      // Row 1 - Basics
      { name: "Default", token: "", color: "#ffffff" },
      { name: "Light Gray", token: "lightgray", color: "#d1d5db" },
      { name: "Gray", token: "gray", color: "#6b7280" },
      { name: "Dark Gray", token: "darkgray", color: "#374151" },
      // Row 2 - Blues
      { name: "Light Blue", token: "lightblue", color: "#93c5fd" },
      { name: "Blue", token: "blue", color: "#3b82f6" },
      { name: "Dark Blue", token: "darkblue", color: "#1e40af" },
      { name: "Indigo", token: "indigo", color: "#6366f1" },
      // Row 3 - Greens
      { name: "Light Green", token: "lightgreen", color: "#86efac" },
      { name: "Green", token: "green", color: "#22c55e" },
      { name: "Dark Green", token: "darkgreen", color: "#15803d" },
      { name: "Teal", token: "teal", color: "#14b8a6" },
      // Row 4 - Warm colors
      { name: "Yellow", token: "yellow", color: "#fbbf24" },
      { name: "Orange", token: "orange", color: "#f97316" },
      { name: "Red", token: "red", color: "#ef4444" },
      { name: "Pink", token: "pink", color: "#ec4899" },
      // Row 5 - Purples
      { name: "Light Purple", token: "lightpurple", color: "#c4b5fd" },
      { name: "Purple", token: "purple", color: "#a855f7" },
      { name: "Dark Purple", token: "darkpurple", color: "#7c3aed" },
      { name: "Fuchsia", token: "fuchsia", color: "#d946ef" }
    ];
    const modal = new ColorPickerModal(this.app, palette, typeName, (selectedToken, selectedName) => {
      if (type === "color") {
        colors[columnIndex] = selectedToken;
      } else {
        borders[columnIndex] = selectedToken;
      }
      let widgetContents = [];
      if (widgetContainer) {
        const columnDivs = widgetContainer.querySelectorAll(".live-column");
        columnDivs.forEach((col) => {
          const markdown = this.extractMarkdownFromHTML(col);
          widgetContents.push(markdown.trim());
        });
      }
      const freshDoc = editor.getValue();
      const freshStartRe = /%%\s*columns:start\s+(\d+)\s*%%/g;
      let freshStartMatch = null;
      let freshMatchCount = 0;
      while ((freshStartMatch = freshStartRe.exec(freshDoc)) !== null) {
        if (freshMatchCount === blockIndex) {
          break;
        }
        freshMatchCount++;
      }
      if (!freshStartMatch) {
        new import_obsidian2.Notice("Block not found.");
        return;
      }
      const freshStartPos = freshStartMatch.index;
      const freshEndRe = /%%\s*columns:end\s*%%/g;
      freshEndRe.lastIndex = freshStartRe.lastIndex;
      const freshEndMatch = freshEndRe.exec(freshDoc);
      if (!freshEndMatch) {
        new import_obsidian2.Notice("Block end not found.");
        return;
      }
      const freshEndPos = freshEndMatch.index + freshEndMatch[0].length;
      if (widgetContents.length > 0) {
        this.applyColumnStylesWithContent(editor, freshStartPos, freshEndPos, num, colors, borders, widgetContents);
      } else {
        this.applyColumnStyles(editor, freshStartPos, freshEndPos, num, colors, borders, freshDoc);
      }
      new import_obsidian2.Notice(`Set column ${columnIndex + 1} ${typeName}: ${selectedName}`);
    });
    modal.open();
  }
  /**
   * Apply styles (colors/borders) to the columns block
   * FIXED: Now properly preserves both colors and borders
   */
  applyColumnStyles(editor, startPos, endPos, numColumns, colors, borders, doc) {
    const blockText = doc.slice(startPos, endPos);
    let newBlock = blockText;
    const updateLine = (prefix, items, text) => {
      const lineContent = `%% ${prefix} ${items.slice(0, numColumns).join("|")} %%`;
      const re = new RegExp(`%%\\s*${prefix.replace(":", "\\:")}\\s+[^\\n%]+\\s*%%`);
      if (re.test(text)) {
        return text.replace(re, lineContent);
      } else {
        const startRe = /%%\s*columns:start\s+(\d+)\s*%%/;
        const startMatch = text.match(startRe);
        if (!startMatch)
          return text;
        const insertPos = startMatch.index + startMatch[0].length;
        return text.slice(0, insertPos) + "\n" + lineContent + text.slice(insertPos);
      }
    };
    const hasColors = colors.some((c) => c);
    if (hasColors) {
      newBlock = updateLine("columns:colors", colors, newBlock);
    } else {
      newBlock = newBlock.replace(/%%\s*columns:colors\s+[^\n%]+\s*%%\n?/g, "");
    }
    const hasBorders = borders.some((b) => b);
    if (hasBorders) {
      newBlock = updateLine("columns:borders", borders, newBlock);
    } else {
      newBlock = newBlock.replace(/%%\s*columns:borders\s+[^\n%]+\s*%%\n?/g, "");
    }
    editor.replaceRange(newBlock, editor.offsetToPos(startPos), editor.offsetToPos(endPos));
  }
  /**
   * Apply styles using content read directly from widget DOM
   * This bypasses document sync entirely and uses the actual widget content
   */
  applyColumnStylesWithContent(editor, startPos, endPos, numColumns, colors, borders, contents) {
    const lines = [];
    lines.push(`%% columns:start ${numColumns} %%`);
    const hasColors = colors.some((c) => c);
    if (hasColors) {
      lines.push(`%% columns:colors ${colors.slice(0, numColumns).join("|")} %%`);
    }
    const hasBorders = borders.some((b) => b);
    if (hasBorders) {
      lines.push(`%% columns:borders ${borders.slice(0, numColumns).join("|")} %%`);
    }
    for (let i = 0; i < numColumns; i++) {
      if (i > 0) {
        lines.push("--- col ---");
      }
      lines.push(contents[i] || "");
    }
    lines.push("%% columns:end %%");
    const newBlock = lines.join("\n");
    editor.replaceRange(newBlock, editor.offsetToPos(startPos), editor.offsetToPos(endPos));
  }
  /**
   * Extract markdown from rendered HTML
   * Converts HTML elements back to markdown syntax
   */
  extractMarkdownFromHTML(el) {
    const clone = el.cloneNode(true);
    let text = clone.innerHTML.replace(/<h(\d)[^>]*>(.+?)<\/h\1>/gi, (_, level, content) => {
      return "#".repeat(parseInt(level)) + " " + content + "\n";
    }).replace(/<strong[^>]*>(.+?)<\/strong>/gi, "**$1**").replace(/<b[^>]*>(.+?)<\/b>/gi, "**$1**").replace(/<em[^>]*>(.+?)<\/em>/gi, "*$1*").replace(/<i[^>]*>(.+?)<\/i>/gi, "*$1*").replace(/<code[^>]*>(.+?)<\/code>/gi, "`$1`").replace(/<a[^>]*href="([^"]*)"[^>]*>(.+?)<\/a>/gi, "[$2]($1)").replace(/<li[^>]*>(.+?)<\/li>/gi, "- $1\n").replace(/<\/?ul[^>]*>/gi, "").replace(/<\/?ol[^>]*>/gi, "").replace(/<div[^>]*>(.+?)<\/div>/gi, "$1\n").replace(/<p[^>]*>(.+?)<\/p>/gi, "$1\n").replace(/<br\s*\/?>/gi, "\n").replace(/<[^>]+>/g, "").replace(/&amp;/g, "&").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&nbsp;/g, " ").replace(/&quot;/g, '"').replace(/\n{3,}/g, "\n\n").trim();
    return text;
  }
  /**
   * Register editor commands for inserting column layouts
   */
  registerCommands() {
    this.addCommand({
      id: "insert-columns-2",
      name: "Insert 2 columns",
      editorCallback: (editor) => {
        this.insertColumns(editor, 2);
      }
    });
    this.addCommand({
      id: "insert-columns-3",
      name: "Insert 3 columns",
      editorCallback: (editor) => {
        this.insertColumns(editor, 3);
      }
    });
    this.addCommand({
      id: "insert-columns-4",
      name: "Insert 4 columns",
      editorCallback: (editor) => {
        this.insertColumns(editor, 4);
      }
    });
    this.addCommand({
      id: "insert-columns",
      name: "Insert columns...",
      editorCallback: (editor) => {
        this.insertColumns(editor, 2);
        new import_obsidian2.Notice("Inserted 2 columns. Use Ctrl+P for more options.");
      }
    });
    this.addCommand({
      id: "change-column-color",
      name: "Change column color...",
      callback: () => {
        this.enterColumnSelectionMode("color");
      }
    });
    this.addCommand({
      id: "change-column-border",
      name: "Change column border...",
      callback: () => {
        this.enterColumnSelectionMode("border");
      }
    });
  }
  /**
   * Insert using the active editor (for ribbon)
   */
  insertColumnsAtActive(numColumns) {
    const view = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
    const editor = view == null ? void 0 : view.editor;
    if (!editor) {
      new import_obsidian2.Notice("No active note to insert columns.");
      return;
    }
    this.insertColumns(editor, numColumns);
  }
  /**
   * Insert a column layout at the current cursor position
   * FIXED: Improved cursor positioning and line breaks
   */
  insertColumns(editor, numColumns) {
    const cursor = editor.getCursor();
    const lineText = editor.getLine(cursor.line);
    const needsKpPre = lineText.trim().length > 0;
    const lines = [];
    if (needsKpPre)
      lines.push("");
    lines.push("");
    lines.push(`%% columns:start ${numColumns} %%`);
    for (let i = 0; i < numColumns; i++) {
      lines.push(`Column ${i + 1}`);
      if (i < numColumns - 1) {
        lines.push("--- col ---");
      }
    }
    lines.push("%% columns:end %%");
    lines.push("");
    const template = lines.join("\n");
    editor.replaceRange(template, cursor);
    const numLinesInserted = lines.length;
    editor.setCursor({
      line: cursor.line + numLinesInserted - 1 + (needsKpPre ? 0 : 0),
      ch: 0
    });
    editor.focus();
  }
  /**
   * Post-processor for Reading mode
   * FINAL FIX: Gets live text from Editor to avoid stale state (1-char lag).
   */
  columnsPostProcessor(el, ctx) {
    const info = ctx.getSectionInfo(el);
    if (!info)
      return;
    let docText = info.text || "";
    const activeLeaf = this.app.workspace.getLeavesOfType("markdown").find(
      (leaf) => {
        var _a;
        return ((_a = leaf.view.file) == null ? void 0 : _a.path) === ctx.sourcePath;
      }
    );
    if (activeLeaf) {
      docText = activeLeaf.view.editor.getValue();
    }
    const docLines = docText.split("\n");
    const elStart = info.lineStart;
    const elEnd = info.lineEnd;
    const startRe = /%%\s*columns:start\s+(\d+)\s*%%/i;
    const endRe = /%%\s*columns:end\s*%%/i;
    let realStartLine = -1;
    let numColumns = 0;
    for (let i = elStart; i <= elEnd; i++) {
      if (!docLines[i])
        continue;
      const line = docLines[i];
      const match = line.match(startRe);
      if (match) {
        realStartLine = i;
        numColumns = parseInt(match[1], 10);
        break;
      }
    }
    if (realStartLine === -1) {
      let insideBlock = false;
      for (let i = elStart - 1; i >= 0; i--) {
        if (!docLines[i])
          continue;
        if (endRe.test(docLines[i]))
          break;
        if (startRe.test(docLines[i])) {
          insideBlock = true;
          break;
        }
      }
      if (insideBlock)
        el.addClass("live-columns-marker-hidden");
      return;
    }
    if (isNaN(numColumns) || numColumns < 1 || numColumns > 6)
      return;
    let blockEndLine = -1;
    const searchLimit = Math.min(docLines.length, realStartLine + 50);
    for (let i = realStartLine + 1; i < searchLimit; i++) {
      if (!docLines[i])
        continue;
      if (endRe.test(docLines[i])) {
        blockEndLine = i;
        break;
      }
    }
    if (blockEndLine === -1)
      return;
    el.empty();
    if (realStartLine > elStart) {
      const preLines = docLines.slice(elStart, realStartLine);
      const preContainer = document.createElement("div");
      preContainer.addClass("live-columns-pre-text");
      preLines.forEach((line) => {
        if (line.trim()) {
          const p = document.createElement("p");
          p.innerText = line;
          preContainer.appendChild(p);
        }
      });
      el.appendChild(preContainer);
    }
    const blockLines = docLines.slice(realStartLine + 1, blockEndLine);
    const columnsContainerWrapper = document.createElement("div");
    this.renderColumnsFromLines(columnsContainerWrapper, blockLines, numColumns);
    el.appendChild(columnsContainerWrapper);
    if (blockEndLine < elEnd) {
      const trailingLines = docLines.slice(blockEndLine + 1, elEnd + 1);
      const trailingContainer = document.createElement("div");
      trailingContainer.addClass("live-columns-trailing-text");
      let hasContent = false;
      trailingLines.forEach((line) => {
        if (startRe.test(line))
          return;
        if (line.trim()) {
          const p = document.createElement("p");
          p.innerText = line;
          trailingContainer.appendChild(p);
          hasContent = true;
        }
      });
      if (hasContent) {
        el.appendChild(trailingContainer);
      }
    }
  }
  /**
   * Helper method to render columns from block content lines
   */
  renderColumnsFromLines(el, blockLines, numColumns) {
    var _a, _b;
    const colorRe = /^%%\s*columns:colors\s+([^\n%]+)\s*%%/i;
    const borderRe = /^%%\s*columns:borders\s+([^\n%]+)\s*%%/i;
    const sepRe = /^---\s*col\s*---$/im;
    let colors = [];
    let borders = [];
    let idx = 0;
    while (idx < blockLines.length) {
      const line = blockLines[idx].trim();
      if (!line) {
        idx += 1;
        continue;
      }
      const colorMatch = line.match(colorRe);
      if (colorMatch) {
        colors = colorMatch[1].split("|").map((c) => c.trim());
        blockLines.splice(idx, 1);
        continue;
      }
      const borderMatch = line.match(borderRe);
      if (borderMatch) {
        borders = borderMatch[1].split("|").map((c) => c.trim());
        blockLines.splice(idx, 1);
        continue;
      }
      break;
    }
    const bodyText = blockLines.join("\n").trim();
    const parts = bodyText.split(sepRe);
    const container = document.createElement("div");
    container.className = `live-columns-container live-columns-${numColumns}`;
    for (let ci = 0; ci < numColumns; ci++) {
      const colDiv = document.createElement("div");
      colDiv.className = "live-column";
      colDiv.setAttribute("data-column-index", ci.toString());
      const colorClass = (_a = colors[ci]) == null ? void 0 : _a.trim();
      if (colorClass) {
        colDiv.classList.add(`live-col-${colorClass}`);
      }
      const borderClass = (_b = borders[ci]) == null ? void 0 : _b.trim();
      if (borderClass) {
        colDiv.classList.add(`live-border-${borderClass}`);
      }
      const contentText = (parts[ci] || "").trim();
      if (contentText.length === 0) {
        const ph = document.createElement("p");
        ph.className = "live-column-empty";
        ph.innerText = `(Column ${ci + 1})`;
        colDiv.appendChild(ph);
      } else {
        const contentLines = contentText.split("\n");
        contentLines.forEach((line, idx2) => {
          if (line.trim()) {
            const p = document.createElement("p");
            p.innerText = line;
            colDiv.appendChild(p);
          } else if (idx2 > 0 && idx2 < contentLines.length - 1) {
            const br = document.createElement("br");
            colDiv.appendChild(br);
          }
        });
      }
      container.appendChild(colDiv);
    }
    while (el.firstChild) {
      el.removeChild(el.firstChild);
    }
    el.appendChild(container);
  }
};
var ColorPickerModal = class extends import_obsidian2.Modal {
  constructor(app, palette, typeName, onSelect) {
    super(app);
    this.palette = palette;
    this.typeName = typeName;
    this.onSelect = onSelect;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("live-columns-color-picker");
    contentEl.createEl("h3", {
      text: `Choose ${this.typeName} color`,
      cls: "color-picker-title"
    });
    const grid = contentEl.createDiv({ cls: "color-grid" });
    this.palette.forEach((p) => {
      const swatch = grid.createDiv({ cls: "color-swatch" });
      swatch.title = p.name;
      if (p.token === "") {
        swatch.addClass("color-swatch-default");
      } else {
        swatch.setCssProps({ "--swatch-color": p.color });
        swatch.style.backgroundColor = p.color;
      }
      swatch.addEventListener("click", () => {
        this.onSelect(p.token, p.name);
        this.close();
      });
    });
    const footer = contentEl.createDiv({ cls: "color-picker-footer" });
    const cancelBtn = footer.createEl("button", { text: "Cancel" });
    cancelBtn.addEventListener("click", () => this.close());
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
